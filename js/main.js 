/* PersonaHire Ultimate - æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ */
/* é¢è¯•åŠŸèƒ½ + AIè°ƒç”¨ + è¯­éŸ³åˆæˆ + ç”¨æˆ·äº¤äº’ */

// =============== AI APIè°ƒç”¨ ===============

/**
 * è°ƒç”¨GPT-4.1 API
 * @param {Array} messages - å¯¹è¯æ¶ˆæ¯æ•°ç»„
 * @returns {Promise<string>} AIå›å¤å†…å®¹
 */
async function callGPT41(messages) {
    const startTime = Date.now();
    
    // è·å–é«˜çº§è®¾ç½®å‚æ•°
    const settings = getAdvancedSettings();
    
    console.log('ğŸ¤– Calling GPT-4.1 API...', {
        messagesCount: messages.length,
        settings: settings
    });
    
    try {
        const response = await retryApiCall(async () => {
            return await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${openaiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4.1',
                    messages: messages,
                    max_tokens: settings.maxTokens,
                    temperature: settings.temperature,
                    presence_penalty: 0.1,
                    frequency_penalty: 0.1
                })
            });
        });

        const responseTime = Date.now() - startTime;

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || 'è¯·æ±‚å¤±è´¥');
        }

        const data = await response.json();
        
        console.log('âœ… GPT-4.1 response received:', {
            usage: data.usage,
            responseTime: responseTime
        });
        
        // è®°å½•Tokenä½¿ç”¨æ—¥å¿—
        if (data.usage) {
            const cost = calculateCost(data.usage.prompt_tokens, data.usage.completion_tokens, 'gpt-4.1');
            logApiCall(
                'gpt-4.1', 
                data.usage.prompt_tokens, 
                data.usage.completion_tokens, 
                cost, 
                responseTime,
                {
                    model: 'gpt-4.1',
                    temperature: settings.temperature,
                    maxTokens: settings.maxTokens
                }
            );
        }
        
        return data.choices[0].message.content;
        
    } catch (error) {
        const errorMessage = handleApiError(error, 'GPT-4.1');
        console.error('âŒ GPT-4.1 API call failed:', error);
        
        // è®°å½•é”™è¯¯æ—¥å¿—
        logApiCall('gpt-4.1', 0, 0, 0, Date.now() - startTime, {
            error: error.message,
            type: 'api_error'
        });
        
        throw new Error(errorMessage);
    }
}

// =============== è¯­éŸ³åˆæˆåŠŸèƒ½ ===============

/**
 * ç”Ÿæˆè¯­éŸ³
 * @param {string} text - è¦åˆæˆçš„æ–‡æœ¬
 * @returns {Promise<string|null>} éŸ³é¢‘URLæˆ–null
 */
async function generateSpeech(text) {
    if (!text || text.trim().length === 0) {
        console.warn('âš ï¸ Empty text provided for speech generation');
        return null;
    }
    
    const cleanText = sanitizeInput(text);
    const settings = getAdvancedSettings();
    
    console.log('ğŸµ Generating speech...', {
        textLength: cleanText.length,
        ttsModel: settings.ttsModel,
        hasElevenKey: !!elevenKey
    });
    
    // ä¼˜å…ˆä½¿ç”¨ElevenLabs TTS
    if (elevenKey && elevenKey !== "your-elevenlabs-api-key-here") {
        const elevenLabsAudio = await generateElevenLabsSpeech(cleanText);
        if (elevenLabsAudio) {
            return elevenLabsAudio;
        }
        console.warn('âš ï¸ ElevenLabs TTS failed, falling back to OpenAI TTS');
    }
    
    // å¤‡é€‰ï¼šä½¿ç”¨OpenAI TTS
    return await generateOpenAISpeech(cleanText, settings.ttsModel);
}

/**
 * ä½¿ç”¨ElevenLabsç”Ÿæˆè¯­éŸ³
 * @param {string} text - æ–‡æœ¬å†…å®¹
 * @returns {Promise<string|null>} éŸ³é¢‘URL
 */
async function generateElevenLabsSpeech(text) {
    const startTime = Date.now();
    
    try {
        const response = await retryApiCall(async () => {
            return await fetch('https://api.elevenlabs.io/v1/text-to-speech/21m00Tcm4TlvDq8ikWAM', {
                method: 'POST',
                headers: {
                    'Accept': 'audio/mpeg',
                    'Content-Type': 'application/json',
                    'xi-api-key': elevenKey
                },
                body: JSON.stringify({
                    text: text,
                    model_id: 'eleven_multilingual_v2',
                    voice_settings: {
                        stability: 0.5,
                        similarity_boost: 0.8,
                        style: 0.3,
                        use_speaker_boost: true
                    }
                })
            });
        });

        const responseTime = Date.now() - startTime;

        if (response.ok) {
            console.log('âœ… ElevenLabs TTS successful');
            
            // è®°å½•ä½¿ç”¨æ—¥å¿—
            const cost = (text.length / 1000) * TOKEN_PRICES['eleven-labs'];
            logApiCall('elevenlabs', 0, text.length, cost, responseTime, {
                textLength: text.length,
                voiceId: '21m00Tcm4TlvDq8ikWAM'
            });
            
            const audioBlob = await response.blob();
            return URL.createObjectURL(audioBlob);
        } else {
            throw new Error(`ElevenLabs API error: ${response.status}`);
        }
    } catch (error) {
        console.error('âŒ ElevenLabs TTS failed:', error);
        
        // è®°å½•é”™è¯¯æ—¥å¿—
        logApiCall('elevenlabs', 0, text.length, 0, Date.now() - startTime, {
            error: error.message,
            type: 'tts_error'
        });
        
        return null;
    }
}

/**
 * ä½¿ç”¨OpenAI TTSç”Ÿæˆè¯­éŸ³
 * @param {string} text - æ–‡æœ¬å†…å®¹
 * @param {string} model - TTSæ¨¡å‹
 * @returns {Promise<string|null>} éŸ³é¢‘URL
 */
async function generateOpenAISpeech(text, model = 'tts-1') {
    const startTime = Date.now();
    
    try {
        const response = await retryApiCall(async () => {
            return await fetch('https://api.openai.com/v1/audio/speech', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${openaiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: model,
                    voice: document.getElementById('voiceStyle')?.value || 'nova',
                    input: text,
                    speed: 1.0
                })
            });
        });

        const responseTime = Date.now() - startTime;

        if (response.ok) {
            console.log('âœ… OpenAI TTS successful');
            
            // è®°å½•ä½¿ç”¨æ—¥å¿—
            const cost = (text.length / 1000) * TOKEN_PRICES[model];
            logApiCall(model, 0, text.length, cost, responseTime, {
                textLength: text.length,
                voice: document.getElementById('voiceStyle')?.value || 'nova'
            });
            
            const audioBlob = await response.blob();
            return URL.createObjectURL(audioBlob);
        } else {
            throw new Error(`OpenAI TTS API error: ${response.status}`);
        }
    } catch (error) {
        console.error('âŒ OpenAI TTS failed:', error);
        
        // è®°å½•é”™è¯¯æ—¥å¿—
        logApiCall(model, 0, text.length, 0, Date.now() - startTime, {
            error: error.message,
            type: 'tts_error'
        });
        
        return null;
    }
}

/**
 * æ’­æ”¾éŸ³é¢‘
 * @param {string} text - è¦æ’­æ”¾çš„æ–‡æœ¬
 */
async function playAudio(text) {
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }

    const audioIndicator = document.getElementById('audioIndicator');
    if (audioIndicator) {
        audioIndicator.style.display = 'block';
    }

    try {
        const audioUrl = await generateSpeech(text);
        if (audioUrl) {
            currentAudio = new Audio(audioUrl);
            
            currentAudio.onended = () => {
                URL.revokeObjectURL(audioUrl);
                currentAudio = null;
            };
            
            currentAudio.onerror = (error) => {
                console.error('âŒ Audio playback error:', error);
                URL.revokeObjectURL(audioUrl);
                currentAudio = null;
            };
            
            await currentAudio.play();
            console.log('ğŸ”Š Audio playback started');
        } else {
            console.warn('âš ï¸ No audio URL generated');
        }
    } catch (error) {
        console.error('âŒ Audio generation/playback failed:', error);
        showError('è¯­éŸ³æ’­æ”¾å¤±è´¥: ' + error.message);
    } finally {
        if (audioIndicator) {
            audioIndicator.style.display = 'none';
        }
    }
}

// =============== é¢è¯•æ§åˆ¶åŠŸèƒ½ ===============

/**
 * å¼€å§‹é¢è¯•
 */
async function startInterview() {
    console.log('ğŸ¯ Starting interview...');
    
    // éªŒè¯APIå¯†é’¥
    if (!openaiKey || (isDeveloperMode && !openaiKey.startsWith('sk-'))) {
        showError('è¯·å…ˆé…ç½®OpenAI API Key');
        return;
    }
    
    // è·å–é¢è¯•è®¾ç½®
    const style = document.getElementById('interviewerStyle')?.value || 'friendly';
    const difficulty = document.getElementById('difficulty')?.value || 'intermediate';
    
    console.log('Interview settings:', { style, difficulty });
    
    // æ„å»ºç³»ç»Ÿæç¤º
    const systemPrompt = `${INTERVIEWER_PERSONALITIES[style]}

é¢è¯•éš¾åº¦: ${DIFFICULTY_SETTINGS[difficulty]}

é¢è¯•è§„åˆ™ï¼š
1. ä¸€æ¬¡åªé—®ä¸€ä¸ªé—®é¢˜ï¼Œç­‰å€™é€‰äººå›ç­”å®Œå†é—®ä¸‹ä¸€ä¸ª
2. æ ¹æ®å€™é€‰äººçš„å›ç­”è¿›è¡Œ3-5è½®æ·±åº¦è¿½é—®
3. è®°ä½ä¹‹å‰çš„æ‰€æœ‰å¯¹è¯å†…å®¹ï¼Œå½¢æˆè¿è´¯çš„é¢è¯•ä½“éªŒ
4. æ¯ä¸ªé—®é¢˜éƒ½è¦æœ‰æ˜ç¡®çš„è€ƒå¯Ÿç›®çš„
5. é¢è¯•æ€»æ—¶é•¿æ§åˆ¶åœ¨15-20åˆ†é’Ÿ
6. é€‚æ—¶ç»™äºˆåé¦ˆå’Œé¼“åŠ±
7. æœ€åè¦ç»™å‡ºç»¼åˆè¯„ä»·

è¯·ç”¨ä¸­æ–‡è¿›è¡Œé¢è¯•ï¼Œä¿æŒä¸“ä¸šä½†å‹å¥½çš„è¯­æ°”ã€‚ç°åœ¨å¼€å§‹ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚`;

    // åˆå§‹åŒ–å¯¹è¯å†å²
    conversationHistory = [
        { role: 'system', content: systemPrompt }
    ];
    
    // ç”Ÿæˆæ–°çš„ä¼šè¯ID
    generateNewSessionId();

    // æ›´æ–°UIçŠ¶æ€
    updateInterviewUIState('running');
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    showLoading(true);

    try {
        const response = await callGPT41(conversationHistory);
        
        // æ·»åŠ AIå›å¤åˆ°å¯¹è¯å†å²
        conversationHistory.push({ role: 'assistant', content: response });
        
        // æ˜¾ç¤ºæ¶ˆæ¯
        addMessage(response, 'interviewer');
        
        // æ’­æ”¾è¯­éŸ³
        await playAudio(response);
        
        interviewStarted = true;
        
        console.log('âœ… Interview started successfully');
        showSuccess('é¢è¯•å·²å¼€å§‹ï¼');
        
    } catch (error) {
        console.error('âŒ Failed to start interview:', error);
        showError('å¯åŠ¨é¢è¯•å¤±è´¥: ' + error.message);
        endInterview();
    } finally {
        showLoading(false);
    }
}

/**
 * å‘é€ç”¨æˆ·æ¶ˆæ¯
 */
async function sendMessage() {
    const userInput = document.getElementById('userInput');
    const message = userInput?.value.trim();

    if (!message) {
        showError('è¯·è¾“å…¥æ‚¨çš„å›ç­”');
        return;
    }
    
    // éªŒè¯æ¶ˆæ¯å†…å®¹
    const validation = validateMessage(message);
    if (!validation.valid) {
        showError(validation.error);
        return;
    }

    console.log('ğŸ“¤ Sending user message...', { messageLength: message.length });

    // æ¸…ç©ºè¾“å…¥æ¡†å¹¶æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
    userInput.value = '';
    addMessage(validation.message, 'user');
    
    // æ›´æ–°UIçŠ¶æ€
    updateSendButtonState('sending');
    showLoading(true);

    // æ·»åŠ åˆ°å¯¹è¯å†å²
    conversationHistory.push({ role: 'user', content: validation.message });

    try {
        const response = await callGPT41(conversationHistory);
        
        // æ·»åŠ AIå›å¤åˆ°å¯¹è¯å†å²
        conversationHistory.push({ role: 'assistant', content: response });
        
        // æ˜¾ç¤ºAIå›å¤
        addMessage(response, 'interviewer');
        
        // æ’­æ”¾è¯­éŸ³
        await playAudio(response);
        
        console.log('âœ… Message sent and response received');
        
    } catch (error) {
        console.error('âŒ Failed to send message:', error);
        showError('å‘é€æ¶ˆæ¯å¤±è´¥: ' + error.message);
        
        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ç»™ç”¨æˆ·
        addMessage('æŠ±æ­‰ï¼Œæˆ‘é‡åˆ°äº†ä¸€äº›æŠ€æœ¯é—®é¢˜ã€‚è¯·ç¨åå†è¯•ã€‚', 'interviewer');
    } finally {
        showLoading(false);
        updateSendButtonState('ready');
    }
}

/**
 * ç”Ÿæˆé¢è¯•æŠ¥å‘Š
 */
async function generateReport() {
    if (conversationHistory.length < 4) {
        showError('é¢è¯•å†…å®¹å¤ªå°‘ï¼Œæ— æ³•ç”Ÿæˆæœ‰æ•ˆæŠ¥å‘Šã€‚è¯·è‡³å°‘è¿›è¡Œ3è½®å¯¹è¯ã€‚');
        return;
    }

    console.log('ğŸ“Š Generating interview report...');
    showLoading(true);

    const reportPrompt = `åŸºäºä»¥ä¸Šå®Œæ•´çš„é¢è¯•å¯¹è¯ï¼Œè¯·ç”Ÿæˆä¸€ä»½ä¸“ä¸šçš„é¢è¯•è¯„ä¼°æŠ¥å‘Šã€‚æŠ¥å‘Šåº”åŒ…æ‹¬ï¼š

1. å€™é€‰äººæ•´ä½“è¡¨ç°æ¦‚è¿°
2. æ ¸å¿ƒèƒ½åŠ›è¯„ä¼°ï¼ˆæŠ€èƒ½ã€æ²Ÿé€šã€é€»è¾‘æ€ç»´ã€åº”å˜èƒ½åŠ›ç­‰ï¼‰
3. å…·ä½“ä¼˜åŠ¿å’Œäº®ç‚¹
4. éœ€è¦æ”¹è¿›çš„æ–¹é¢
5. é¢è¯•è¡¨ç°æ‰“åˆ†ï¼ˆ1-10åˆ†ï¼Œå„ç»´åº¦è¯¦ç»†è¯´æ˜ï¼‰
6. å½•ç”¨å»ºè®®ï¼ˆæ¨è/æœ‰æ¡ä»¶æ¨è/ä¸æ¨èï¼‰
7. é’ˆå¯¹æ€§çš„èŒä¸šå‘å±•å»ºè®®

è¯·ç”¨ä¸“ä¸šã€å®¢è§‚ã€å»ºè®¾æ€§çš„è¯­è¨€æ’°å†™ï¼ŒæŠ¥å‘Šè¦å…·ä½“ã€æœ‰é’ˆå¯¹æ€§ã€‚`;

    try {
        const reportHistory = [...conversationHistory, { role: 'user', content: reportPrompt }];
        const report = await callGPT41(reportHistory);
        
        addMessage(`ğŸ“Š **é¢è¯•è¯„ä¼°æŠ¥å‘Š**\n\n${report}`, 'interviewer');
        await playAudio('æ‚¨çš„ä¸“ä¸šé¢è¯•è¯„ä¼°æŠ¥å‘Šå·²ç»ç”Ÿæˆå®Œæˆï¼Œè¯·æŸ¥çœ‹è¯¦ç»†åˆ†æå’Œå»ºè®®ã€‚');
        
        console.log('âœ… Interview report generated successfully');
        showSuccess('é¢è¯•æŠ¥å‘Šç”ŸæˆæˆåŠŸï¼');
        
    } catch (error) {
        console.error('âŒ Failed to generate report:', error);
        showError('ç”ŸæˆæŠ¥å‘Šå¤±è´¥: ' + error.message);
    } finally {
        showLoading(false);
    }
}

/**
 * ç»“æŸé¢è¯•
 */
function endInterview() {
    console.log('ğŸ Ending interview...');
    
    interviewStarted = false;
    updateInterviewUIState('ended');
    
    addMessage('é¢è¯•ç»“æŸï¼Œæ„Ÿè°¢æ‚¨çš„å‚ä¸ï¼å¦‚éœ€æŸ¥çœ‹è¯¦ç»†è¯„ä¼°ï¼Œè¯·ç‚¹å‡»"ç”ŸæˆæŠ¥å‘Š"æŒ‰é’®ã€‚', 'interviewer');
    playAudio('é¢è¯•ç»“æŸï¼Œæ„Ÿè°¢æ‚¨çš„å‚ä¸ï¼');
    
    console.log('âœ… Interview ended');
    showSuccess('é¢è¯•å·²ç»“æŸ');
}

/**
 * æ¸…ç©ºèŠå¤©è®°å½•
 */
function clearChat() {
    console.log('ğŸ—‘ï¸ Clearing chat...');
    
    const chatArea = document.getElementById('chatArea');
    if (chatArea) {
        chatArea.innerHTML = `
            <div class="message interviewer">
                <strong>ğŸ­ AIé¢è¯•å®˜ Sarahï¼š</strong>
                æ¬¢è¿æ¥åˆ°PersonaHire Ultimateï¼æˆ‘å·²å‡†å¤‡å¥½å¼€å§‹æ–°çš„é¢è¯•ã€‚è¯·é…ç½®å¥½è®¾ç½®åç‚¹å‡»"å¼€å§‹é¢è¯•"ã€‚
                <div class="voice-controls">
                    <button class="voice-btn" onclick="playWelcomeMessage()">ğŸ”Š å¬è¯­éŸ³æ¬¢è¿</button>
                </div>
            </div>
        `;
    }
    
    // é‡ç½®å¯¹è¯å†å²
    conversationHistory = [];
    
    // é‡ç½®ç»Ÿè®¡æ•°æ®å’Œç”Ÿæˆæ–°ä¼šè¯ID
    apiCallCount = 0;
    totalTokensUsed = 0;
    responseTimes = [];
    generateNewSessionId();
    
    // æ›´æ–°ç»Ÿè®¡æ˜¾ç¤º
    if (isDeveloperMode && document.getElementById('apiCallCount')) {
        updateUsageStats(0, 0, 0);
    }
    
    // é‡ç½®UIçŠ¶æ€
    updateInterviewUIState('ready');
    
    console.log('âœ… Chat cleared');
    showSuccess('å¯¹è¯å·²æ¸…ç©º');
}

// =============== å¯¹è¯å¯¼å‡ºåŠŸèƒ½ ===============

/**
 * å¯¼å‡ºå¯¹è¯è®°å½•
 */
function exportConversation() {
    if (conversationHistory.length === 0) {
        showError('æ²¡æœ‰å¯¹è¯å†…å®¹å¯ä»¥å¯¼å‡º');
        return;
    }

    console.log('ğŸ’¾ Exporting conversation...');

    const exportData = {
        exportInfo: {
            timestamp: new Date().toISOString(),
            mode: isDeveloperMode ? 'developer' : 'user',
            sessionId: currentSessionId,
            totalMessages: conversationHistory.length
        },
        interviewSettings: {
            interviewer: document.getElementById('interviewerStyle')?.value || 'unknown',
            difficulty: document.getElementById('difficulty')?.value || 'unknown',
            voice: document.getElementById('voiceStyle')?.value || 'unknown'
        },
        statistics: {
            apiCalls: apiCallCount,
            tokensUsed: totalTokensUsed,
            estimatedCost: calculateTotalCost(),
            avgResponseTime: responseTimes.length > 0 ? 
                Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length) : 0,
            sessionDuration: Math.round((Date.now() - sessionStartTime) / 1000)
        },
        conversation: conversationHistory.filter(msg => msg.role !== 'system'), // æ’é™¤ç³»ç»Ÿæç¤º
        tokenLogs: isDeveloperMode ? getLogsForTimeRange('today') : undefined
    };

    const filename = `interview-${currentSessionId}-${Date.now()}.json`;
    downloadAsJSON(exportData, filename);
    
    console.log('âœ… Conversation exported');
    showSuccess('å¯¹è¯å·²å¯¼å‡ºåˆ°æœ¬åœ°æ–‡ä»¶');
}

// =============== UIçŠ¶æ€ç®¡ç† ===============

/**
 * æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©åŒºåŸŸ
 * @param {string} content - æ¶ˆæ¯å†…å®¹
 * @param {string} sender - å‘é€è€…ç±»å‹ (interviewer/user)
 */
function addMessage(content, sender) {
    const chatArea = document.getElementById('chatArea');
    if (!chatArea) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}`;
    
    const senderName = sender === 'interviewer' ? 'ğŸ­ AIé¢è¯•å®˜ Sarah' : 'ğŸ‘¤ æ‚¨';
    const safeContent = content.replace(/\n/g, '<br>');
    messageDiv.innerHTML = `<strong>${senderName}ï¼š</strong>${safeContent}`;
    
    // ä¸ºé¢è¯•å®˜æ¶ˆæ¯æ·»åŠ è¯­éŸ³æ§åˆ¶
    if (sender === 'interviewer') {
        const voiceControls = document.createElement('div');
        voiceControls.className = 'voice-controls';
        voiceControls.innerHTML = `<button class="voice-btn" onclick="playAudio('${content.replace(/'/g, "\\'")}')">ğŸ”Š é‡æ’­è¯­éŸ³</button>`;
        messageDiv.appendChild(voiceControls);
    }
    
    chatArea.appendChild(messageDiv);
    chatArea.scrollTop = chatArea.scrollHeight;
}

/**
 * æ›´æ–°é¢è¯•UIçŠ¶æ€
 * @param {string} state - çŠ¶æ€ (ready/running/ended)
 */
function updateInterviewUIState(state) {
    const startBtn = document.getElementById('startBtn');
    const endBtn = document.getElementById('endBtn');
    const reportBtn = document.getElementById('reportBtn');
    const userInput = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    
    switch (state) {
        case 'ready':
            if (startBtn) startBtn.disabled = false;
            if (endBtn) endBtn.disabled = true;
            if (reportBtn) reportBtn.disabled = true;
            if (userInput) userInput.disabled = true;
            if (sendBtn) sendBtn.disabled = true;
            break;
            
        case 'running':
            if (startBtn) startBtn.disabled = true;
            if (endBtn) endBtn.disabled = false;
            if (reportBtn) reportBtn.disabled = false;
            if (userInput) userInput.disabled = false;
            if (sendBtn) sendBtn.disabled = false;
            break;
            
        case 'ended':
            if (startBtn) startBtn.disabled = false;
            if (endBtn) endBtn.disabled = true;
            if (userInput) userInput.disabled = true;
            if (sendBtn) sendBtn.disabled = true;
            break;
    }
}

/**
 * æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
 * @param {string} state - çŠ¶æ€ (ready/sending)
 */
function updateSendButtonState(state) {
    const sendBtn = document.getElementById('sendBtn');
    if (!sendBtn) return;
    
    switch (state) {
        case 'ready':
            sendBtn.disabled = false;
            sendBtn.textContent = 'ğŸ“¤ å‘é€å›ç­”';
            break;
        case 'sending':
            sendBtn.disabled = true;
            sendBtn.textContent = 'â³ å‘é€ä¸­...';
            break;
    }
}

/**
 * æ˜¾ç¤º/éšè—åŠ è½½çŠ¶æ€
 * @param {boolean} show - æ˜¯å¦æ˜¾ç¤º
 */
function showLoading(show) {
    const loading = document.getElementById('loading');
    if (loading) {
        loading.style.display = show ? 'block' : 'none';
    }
}

// =============== æ¬¢è¿æ¶ˆæ¯æ’­æ”¾ ===============

/**
 * æ’­æ”¾æ¬¢è¿æ¶ˆæ¯
 */
async function playWelcomeMessage() {
    const welcomeText = "æ¬¢è¿æ¥åˆ°PersonaHire Ultimateï¼æˆ‘æ˜¯æ‚¨çš„ä¸“å±AIé¢è¯•å®˜Sarahï¼Œæ­è½½äº†æœ€å¼ºå¤§çš„GPT-4.1æ¨ç†å¼•æ“ã€‚è®©æˆ‘ä»¬å¼€å§‹ä¸€åœºç²¾å½©çš„é¢è¯•å§ï¼";
    await playAudio(welcomeText);
}

// =============== äº‹ä»¶ç›‘å¬å™¨è®¾ç½® ===============

/**
 * è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
 */
function setupEventListeners() {
    // å›è½¦å‘é€æ¶ˆæ¯
    const userInput = document.getElementById('userInput');
    if (userInput) {
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    }
    
    console.log('âœ… Event listeners setup complete');
}

// =============== æ¨¡å—å¯¼å‡º ===============

// ç¡®ä¿å…¨å±€å¯è®¿é—®çš„å‡½æ•°
window.callGPT41 = callGPT41;
window.generateSpeech = generateSpeech;
window.playAudio = playAudio;
window.startInterview = startInterview;
window.sendMessage = sendMessage;
window.generateReport = generateReport;
window.endInterview = endInterview;
window.clearChat = clearChat;
window.exportConversation = exportConversation;
window.addMessage = addMessage;
window.playWelcomeMessage = playWelcomeMessage;
window.setupEventListeners = setupEventListeners;

console.log('ğŸš€ Main module loaded successfully');
