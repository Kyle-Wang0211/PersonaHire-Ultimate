// PersonaHire Ultimate - ä¸»åŠŸèƒ½æ¨¡å—
// è´Ÿè´£æ ¸å¿ƒé¢è¯•åŠŸèƒ½ã€APIè°ƒç”¨ã€UIäº¤äº’ã€è¯­éŸ³åˆæˆ

class UIManager {
    constructor() {
        this.messageQueue = [];
        this.isProcessing = false;
    }

    showMessage(message, type = 'info') {
        const statusDiv = document.getElementById('statusMessage');
        statusDiv.className = type;
        statusDiv.innerHTML = message;
        statusDiv.style.display = 'block';
        
        setTimeout(() => {
            statusDiv.style.display = 'none';
        }, 5000);
    }

    showError(message) {
        this.showMessage(message, 'error');
    }

    showSuccess(message) {
        this.showMessage(message, 'success');
    }

    showWarning(message) {
        this.showMessage(message, 'warning');
    }

    setLoading(show, message = 'ğŸ¤– AIé¢è¯•å®˜æ­£åœ¨æ·±åº¦æ€è€ƒä¸­...') {
        const loadingDiv = document.getElementById('loading');
        if (show) {
            document.getElementById('loading').innerHTML = message;
            loadingDiv.style.display = 'block';
        } else {
            loadingDiv.style.display = 'none';
        }
    }

    updateButtonStates(state) {
        const buttons = {
            'startBtn': state.canStart,
            'endBtn': state.canEnd,
            'reportBtn': state.canReport,
            'sendBtn': state.canSend,
            'userInput': state.canInput
        };

        Object.entries(buttons).forEach(([id, enabled]) => {
            const element = document.getElementById(id);
            if (element) {
                if (id === 'userInput') {
                    element.disabled = !enabled;
                } else {
                    element.disabled = !enabled;
                }
            }
        });
    }
}

class AudioManager {
    constructor() {
        this.currentAudio = null;
        this.audioQueue = [];
        this.isPlaying = false;
    }

    async generateSpeech(text, voice = 'nova') {
        const audioIndicator = document.getElementById('audioIndicator');
        audioIndicator.style.display = 'block';

        try {
            // ä¼˜å…ˆä½¿ç”¨ElevenLabs
            if (window.configManager.apiKeys.elevenlabs && 
                window.configManager.apiKeys.elevenlabs !== "your-elevenlabs-api-key-here") {
                return await this.generateElevenLabsSpeech(text);
            }
            
            // å¤‡é€‰OpenAI TTS
            return await this.generateOpenAISpeech(text, voice);
        } catch (error) {
            console.error('è¯­éŸ³ç”Ÿæˆå¤±è´¥:', error);
            return null;
        } finally {
            audioIndicator.style.display = 'none';
        }
    }

    async generateElevenLabsSpeech(text) {
        const response = await fetch('https://api.elevenlabs.io/v1/text-to-speech/21m00Tcm4TlvDq8ikWAM', {
            method: 'POST',
            headers: {
                'Accept': 'audio/mpeg',
                'Content-Type': 'application/json',
                'xi-api-key': window.configManager.apiKeys.elevenlabs
            },
            body: JSON.stringify({
                text: text,
                model_id: 'eleven_multilingual_v2',
                voice_settings: {
                    stability: 0.5,
                    similarity_boost: 0.8,
                    style: 0.3,
                    use_speaker_boost: true
                }
            })
        });

        if (response.ok) {
            const audioBlob = await response.blob();
            return URL.createObjectURL(audioBlob);
        }
        throw new Error('ElevenLabs TTS failed');
    }

    async generateOpenAISpeech(text, voice) {
        const response = await fetch('https://api.openai.com/v1/audio/speech', {
            method: 'POST',
            headers: window.securityManager.getSecureHeaders(window.configManager.apiKeys.openai),
            body: JSON.stringify({
                model: 'tts-1',
                voice: voice,
                input: text,
                speed: 1.0
            })
        });

        if (response.ok) {
            const audioBlob = await response.blob();
            return URL.createObjectURL(audioBlob);
        }
        throw new Error('OpenAI TTS failed');
    }

    async playAudio(text, voice = null) {
        if (this.currentAudio) {
            this.currentAudio.pause();
        }

        try {
            const voiceStyle = voice || document.getElementById('voiceStyle').value;
            const audioUrl = await this.generateSpeech(text, voiceStyle);
            
            if (audioUrl) {
                this.currentAudio = new Audio(audioUrl);
                this.isPlaying = true;
                
                this.currentAudio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    this.isPlaying = false;
                };

                this.currentAudio.onerror = () => {
                    console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥');
                    this.isPlaying = false;
                };

                await this.currentAudio.play();
            }
        } catch (error) {
            console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
            this.isPlaying = false;
        }
    }

    stopAudio() {
        if (this.currentAudio) {
            this.currentAudio.pause();
            this.currentAudio = null;
            this.isPlaying = false;
        }
    }
}

class APIManager {
    constructor() {
        this.requestCount = 0;
        this.lastRequestTime = 0;
    }

    async callGPT(messages, customConfig = {}) {
        // å®‰å…¨éªŒè¯
        const rateCheck = window.securityManager.checkRateLimit();
        if (!rateCheck.allowed) {
            throw new Error(rateCheck.error);
        }

        // è·å–é…ç½®
        const config = {
            ...window.configManager.getGPTConfig(),
            ...customConfig,
            messages: messages
        };

        // Tokenä¼˜åŒ–
        if (window.configManager.settings.tokenOptimization) {
            config.messages = window.tokenMonitor.optimizeContext(messages);
        }

        // æ™ºèƒ½æ‘˜è¦
        if (window.configManager.settings.smartSummary && messages.length > 10) {
            config.messages = await window.tokenMonitor.generateSmartSummary(messages);
        }

        const startTime = Date.now();

        try {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: window.securityManager.getSecureHeaders(window.configManager.apiKeys.openai),
                body: JSON.stringify(config)
            });

            const responseTime = Date.now() - startTime;

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(window.securityManager.handleSecureError(errorData, 'GPT API'));
            }

            const data = await response.json();
            
            // éªŒè¯å“åº”
            const validation = window.securityManager.validateApiResponse(data, ['choices']);
            if (!validation.valid) {
                throw new Error(validation.error);
            }

            // è®°å½•Tokenä½¿ç”¨
            const inputText = messages.map(m => m.content).join(' ');
            const outputText = data.choices[0].message.content;
            
            window.tokenMonitor.recordRequest(
                config.model, 
                inputText, 
                outputText, 
                data.usage
            );

            // è®°å½•è¯·æ±‚ç»Ÿè®¡
            this.requestCount++;
            this.lastRequestTime = Date.now();

            return data.choices[0].message.content;

        } catch (error) {
            console.error('GPT APIè°ƒç”¨å¤±è´¥:', error);
            throw new Error(window.securityManager.handleSecureError(error, 'GPT APIè°ƒç”¨'));
        }
    }
}

class InterviewManager {
    constructor() {
        this.conversationHistory = [];
        this.interviewStarted = false;
        this.interviewData = {
            startTime: null,
            endTime: null,
            responses: [],
            personality: null,
            difficulty: null
        };
    }

    async startInterview() {
        // éªŒè¯é…ç½®
        if (!window.configManager.apiKeys.openai || 
            (window.configManager.isDeveloperMode && !window.configManager.apiKeys.openai.startsWith('sk-'))) {
            window.uiManager.showError('è¯·å…ˆé…ç½®OpenAI API Key');
            return;
        }

        const style = document.getElementById('interviewerStyle').value;
        const difficulty = document.getElementById('difficulty').value;

        // è®°å½•é¢è¯•ä¿¡æ¯
        this.interviewData = {
            startTime: new Date(),
            personality: style,
            difficulty: difficulty,
            responses: []
        };

        // æ„å»ºç³»ç»Ÿæç¤º
        const personalities = window.configManager.getInterviewerPersonalities();
        const difficultySettings = window.configManager.getDifficultySettings();

        let systemPrompt = `${personalities[style]}

é¢è¯•éš¾åº¦: ${difficultySettings[difficulty]}

é¢è¯•è§„åˆ™ï¼š
1. ä¸€æ¬¡åªé—®ä¸€ä¸ªé—®é¢˜ï¼Œç­‰å€™é€‰äººå›ç­”å®Œå†é—®ä¸‹ä¸€ä¸ª
2. æ ¹æ®å€™é€‰äººçš„å›ç­”è¿›è¡Œ3-5è½®æ·±åº¦è¿½é—®
3. è®°ä½ä¹‹å‰çš„æ‰€æœ‰å¯¹è¯å†…å®¹ï¼Œå½¢æˆè¿è´¯çš„é¢è¯•ä½“éªŒ
4. æ¯ä¸ªé—®é¢˜éƒ½è¦æœ‰æ˜ç¡®çš„è€ƒå¯Ÿç›®çš„
5. é¢è¯•æ€»æ—¶é•¿æ§åˆ¶åœ¨15-20åˆ†é’Ÿ
6. é€‚æ—¶ç»™äºˆåé¦ˆå’Œé¼“åŠ±
7. æœ€åè¦ç»™å‡ºç»¼åˆè¯„ä»·

è¯·ç”¨ä¸­æ–‡è¿›è¡Œé¢è¯•ï¼Œä¿æŒä¸“ä¸šä½†å‹å¥½çš„è¯­æ°”ã€‚ç°åœ¨å¼€å§‹ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚`;

        // è‡ªé€‚åº”éš¾åº¦è°ƒæ•´
        if (window.configManager.settings.adaptiveDifficulty) {
            systemPrompt += `\n\nç‰¹åˆ«è¯´æ˜ï¼šè¯·æ ¹æ®å€™é€‰äººçš„å›ç­”è´¨é‡åŠ¨æ€è°ƒæ•´é—®é¢˜éš¾åº¦ã€‚å¦‚æœå›ç­”ä¼˜ç§€ï¼Œå¯ä»¥æé«˜éš¾åº¦ï¼›å¦‚æœå›ç­”ä¸å¤Ÿç†æƒ³ï¼Œå¯ä»¥é€‚å½“é™ä½éš¾åº¦ã€‚`;
        }

        this.conversationHistory = [
            { role: 'system', content: systemPrompt }
        ];

        // æ›´æ–°UIçŠ¶æ€
        window.uiManager.updateButtonStates({
            canStart: false,
            canEnd: true,
            canReport: true,
            canSend: true,
            canInput: true
        });

        window.uiManager.setLoading(true, 'ğŸ¤– AIé¢è¯•å®˜æ­£åœ¨å‡†å¤‡ç¬¬ä¸€ä¸ªé—®é¢˜...');

        try {
            const response = await window.apiManager.callGPT(this.conversationHistory);
            this.addMessage(response, 'interviewer');
            await window.audioManager.playAudio(response);
            
            this.interviewStarted = true;
            window.uiManager.showSuccess('âœ… é¢è¯•å¼€å§‹ï¼è¯·å›ç­”é¢è¯•å®˜çš„é—®é¢˜ã€‚');
            
        } catch (error) {
            window.uiManager.showError('å¯åŠ¨é¢è¯•å¤±è´¥: ' + error.message);
            this.endInterview();
        } finally {
            window.uiManager.setLoading(false);
        }
    }

    async sendMessage() {
        const userInput = document.getElementById('userInput');
        const message = userInput.value.trim();

        if (!message) {
            window.uiManager.showError('è¯·è¾“å…¥æ‚¨çš„å›ç­”');
            return;
        }

        // å®‰å…¨éªŒè¯
        const inputValidation = window.securityManager.validateUserInput(message);
        if (!inputValidation.valid) {
            window.uiManager.showError(inputValidation.error);
            return;
        }

        // æ£€æµ‹æç¤ºæ³¨å…¥
        const injectionCheck = window.securityManager.detectPromptInjection(message);
        if (injectionCheck.detected) {
            window.uiManager.showError(injectionCheck.error);
            return;
        }

        // æ¸…ç†è¾“å…¥
        const cleanMessage = window.securityManager.sanitizeInput(message);

        // è®°å½•ç”¨æˆ·å›ç­”
        this.interviewData.responses.push({
            question: this.getLastInterviewerMessage(),
            answer: cleanMessage,
            timestamp: new Date()
        });

        this.addMessage(cleanMessage, 'user');
        userInput.value = '';

        window.uiManager.setLoading(true);
        window.uiManager.updateButtonStates({
            canStart: false,
            canEnd: true,
            canReport: true,
            canSend: false,
            canInput: true
        });

        this.conversationHistory.push({ role: 'user', content: cleanMessage });

        try {
            const response = await window.apiManager.callGPT(this.conversationHistory);
            this.conversationHistory.push({ role: 'assistant', content: response });
            
            this.addMessage(response, 'interviewer');
            await window.audioManager.playAudio(response);

            // æ˜¾ç¤ºä¼˜åŒ–å»ºè®®
            const suggestions = window.tokenMonitor.getOptimizationSuggestion();
            if (suggestions.length > 0) {
                console.log('ä¼˜åŒ–å»ºè®®:', suggestions);
            }

        } catch (error) {
            window.uiManager.showError('å‘é€æ¶ˆæ¯å¤±è´¥: ' + error.message);
            this.addMessage('æŠ±æ­‰ï¼Œæˆ‘é‡åˆ°äº†ä¸€äº›æŠ€æœ¯é—®é¢˜ã€‚è¯·ç¨åå†è¯•ã€‚', 'interviewer');
        } finally {
            window.uiManager.setLoading(false);
            window.uiManager.updateButtonStates({
                canStart: false,
                canEnd: true,
                canReport: true,
                canSend: true,
                canInput: true
            });
        }
    }

    getLastInterviewerMessage() {
        for (let i = this.conversationHistory.length - 1; i >= 0; i--) {
            if (this.conversationHistory[i].role === 'assistant') {
                return this.conversationHistory[i].content;
            }
        }
        return '';
    }

    async generateReport() {
        if (this.conversationHistory.length < 4) {
            window.uiManager.showError('é¢è¯•å†…å®¹å¤ªå°‘ï¼Œæ— æ³•ç”Ÿæˆæœ‰æ•ˆæŠ¥å‘Šã€‚è¯·è‡³å°‘è¿›è¡Œ3è½®å¯¹è¯ã€‚');
            return;
        }

        window.uiManager.setLoading(true, 'ğŸ“Š æ­£åœ¨ç”Ÿæˆä¸“ä¸šé¢è¯•è¯„ä¼°æŠ¥å‘Š...');

        const reportPrompt = `åŸºäºä»¥ä¸Šå®Œæ•´çš„é¢è¯•å¯¹è¯ï¼Œè¯·ç”Ÿæˆä¸€ä»½ä¸“ä¸šçš„é¢è¯•è¯„ä¼°æŠ¥å‘Šã€‚

é¢è¯•ä¿¡æ¯ï¼š
- é¢è¯•å®˜ç±»å‹ï¼š${this.interviewData.personality}
- éš¾åº¦ç­‰çº§ï¼š${this.interviewData.difficulty}
- é¢è¯•æ—¶é•¿ï¼š${this.getInterviewDuration()}
- å¯¹è¯è½®æ•°ï¼š${this.conversationHistory.filter(m => m.role === 'user').length}

è¯·æŒ‰ä»¥ä¸‹ç»“æ„ç”ŸæˆæŠ¥å‘Šï¼š

## ğŸ¯ å€™é€‰äººæ•´ä½“è¡¨ç°
[ç®€è¦æ¦‚è¿°å€™é€‰äººçš„æ•´ä½“è¡¨ç°ï¼Œçªå‡ºä¸»è¦ä¼˜åŠ¿]

## ğŸ“Š æ ¸å¿ƒèƒ½åŠ›è¯„ä¼°
### æ²Ÿé€šè¡¨è¾¾èƒ½åŠ› (X/10åˆ†)
[å…·ä½“è¯„ä»·å’Œä¾‹å­]

### é€»è¾‘æ€ç»´èƒ½åŠ› (X/10åˆ†)
[å…·ä½“è¯„ä»·å’Œä¾‹å­]

### ä¸“ä¸šæŠ€èƒ½æ°´å¹³ (X/10åˆ†)
[å…·ä½“è¯„ä»·å’Œä¾‹å­]

### åº”å˜é€‚åº”èƒ½åŠ› (X/10åˆ†)
[å…·ä½“è¯„ä»·å’Œä¾‹å­]

## âœ¨ ä¸»è¦ä¼˜åŠ¿ä¸äº®ç‚¹
- [å…·ä½“ä¼˜åŠ¿1]
- [å…·ä½“ä¼˜åŠ¿2]
- [å…·ä½“ä¼˜åŠ¿3]

## ğŸ”§ éœ€è¦æ”¹è¿›çš„æ–¹é¢
- [æ”¹è¿›å»ºè®®1]
- [æ”¹è¿›å»ºè®®2]
- [æ”¹è¿›å»ºè®®3]

## ğŸ“ˆ ç»¼åˆè¯„åˆ†
**æ€»åˆ†ï¼šX/10åˆ†**

## ğŸ’¼ å½•ç”¨å»ºè®®
[æ¨è/æœ‰æ¡ä»¶æ¨è/ä¸æ¨èï¼Œå¹¶è¯´æ˜ç†ç”±]

## ğŸš€ èŒä¸šå‘å±•å»ºè®®
[é’ˆå¯¹æ€§çš„å‘å±•å»ºè®®]

è¯·ç”¨ä¸“ä¸šã€å®¢è§‚ã€å»ºè®¾æ€§çš„è¯­è¨€æ’°å†™ï¼ŒæŠ¥å‘Šè¦å…·ä½“ã€æœ‰é’ˆå¯¹æ€§ï¼Œé¿å…ç©ºæ³›çš„è¯„ä»·ã€‚`;

        try {
            const reportHistory = [...this.conversationHistory, { role: 'user', content: reportPrompt }];
            const report = await window.apiManager.callGPT(reportHistory, { 
                max_tokens: 1500,
                temperature: 0.3 
            });
            
            this.addMessage(`ğŸ“Š **é¢è¯•è¯„ä¼°æŠ¥å‘Š**\n\n${report}`, 'interviewer');
            
            // ä¿å­˜æŠ¥å‘Š
            this.interviewData.finalReport = report;
            this.interviewData.reportGeneratedAt = new Date();
            
            await window.audioManager.playAudio('æ‚¨çš„ä¸“ä¸šé¢è¯•è¯„ä¼°æŠ¥å‘Šå·²ç»ç”Ÿæˆå®Œæˆï¼Œè¯·æŸ¥çœ‹è¯¦ç»†åˆ†æå’Œå»ºè®®ã€‚');
            window.uiManager.showSuccess('âœ… é¢è¯•æŠ¥å‘Šç”ŸæˆæˆåŠŸï¼');
            
        } catch (error) {
            window.uiManager.showError('ç”ŸæˆæŠ¥å‘Šå¤±è´¥: ' + error.message);
        } finally {
            window.uiManager.setLoading(false);
        }
    }

    getInterviewDuration() {
        if (!this.interviewData.startTime) return 'æœªçŸ¥';
        const duration = (new Date() - this.interviewData.startTime) / 1000 / 60;
        return `${Math.round(duration)}åˆ†é’Ÿ`;
    }

    addMessage(content, sender) {
        const chatArea = document.getElementById('chatArea');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${sender}`;
        
        const senderName = sender === 'interviewer' ? 'ğŸ­ AIé¢è¯•å®˜ Sarah' : 'ğŸ‘¤ æ‚¨';
        const timestamp = new Date().toLocaleTimeString();
        
        messageDiv.innerHTML = `
            <strong>${senderName}ï¼š</strong>
            <span style="font-size: 0.8em; color: #666; float: right;">${timestamp}</span>
            <br>
            ${content.replace(/\n/g, '<br>')}
        `;
        
        if (sender === 'interviewer') {
            const voiceControls = document.createElement('div');
            voiceControls.className = 'voice-controls';
            voiceControls.innerHTML = `
                <button class="voice-btn" onclick="window.audioManager.playAudio('${content.replace(/'/g, "\\'")}')">
                    ğŸ”Š é‡æ’­è¯­éŸ³
                </button>
            `;
            messageDiv.appendChild(voiceControls);
        }
        
        chatArea.appendChild(messageDiv);
        chatArea.scrollTop = chatArea.scrollHeight;
    }

    endInterview() {
        this.interviewStarted = false;
        this.interviewData.endTime = new Date();
        
        window.uiManager.updateButtonStates({
            canStart: true,
            canEnd: false,
            canReport: this.conversationHistory.length >= 4,
            canSend: false,
            canInput: false
        });
        
        this.addMessage('é¢è¯•ç»“æŸï¼Œæ„Ÿè°¢æ‚¨çš„å‚ä¸ï¼å¦‚éœ€æŸ¥çœ‹è¯¦ç»†è¯„ä¼°ï¼Œè¯·ç‚¹å‡»"ç”ŸæˆæŠ¥å‘Š"æŒ‰é’®ã€‚', 'interviewer');
        window.audioManager.playAudio('é¢è¯•ç»“æŸï¼Œæ„Ÿè°¢æ‚¨çš„å‚ä¸ï¼');
        
        window.uiManager.showSuccess('é¢è¯•å·²ç»“æŸã€‚æ‚¨å¯ä»¥ç”Ÿæˆè¯„ä¼°æŠ¥å‘ŠæŸ¥çœ‹è¡¨ç°åˆ†æã€‚');
    }

    clearChat() {
        const chatArea = document.getElementById('chatArea');
        chatArea.innerHTML = `
            <div class="message interviewer">
                <strong>ğŸ­ AIé¢è¯•å®˜ Sarahï¼š</strong>
                <br>
                æ¬¢è¿æ¥åˆ°PersonaHire Ultimateï¼æˆ‘å·²å‡†å¤‡å¥½å¼€å§‹æ–°çš„é¢è¯•ã€‚è¯·é…ç½®å¥½è®¾ç½®åç‚¹å‡»"å¼€å§‹é¢è¯•"ã€‚
                <div class="voice-controls">
                    <button class="voice-btn" onclick="window.audioManager.playAudio('æ¬¢è¿å›æ¥ï¼æˆ‘å·²å‡†å¤‡å¥½å¼€å§‹æ–°çš„é¢è¯•ã€‚')">
                        ğŸ”Š å¬è¯­éŸ³æ¬¢è¿
                    </button>
                </div>
            </div>
        `;
        
        this.conversationHistory = [];
        this.interviewData = {
            startTime: null,
            endTime: null,
            responses: [],
            personality: null,
            difficulty: null
        };
        
        window.uiManager.updateButtonStates({
            canStart: true,
            canEnd: false,
            canReport: false,
            canSend: false,
            canInput: false
        });
    }
}

class ExportManager {
    constructor() {
        this.supportedFormats = ['json', 'txt', 'html'];
    }

    exportConversation(format = 'json') {
        const data = this.prepareExportData();
        
        switch (format) {
            case 'json':
                this.exportAsJSON(data);
                break;
            case 'txt':
                this.exportAsText(data);
                break;
            case 'html':
                this.exportAsHTML(data);
                break;
            default:
                window.uiManager.showError('ä¸æ”¯æŒçš„å¯¼å‡ºæ ¼å¼');
        }
    }

    prepareExportData() {
        return {
            metadata: {
                exportTime: new Date().toISOString(),
                platform: 'PersonaHire Ultimate',
                version: '1.0',
                interviewData: window.interviewManager.interviewData
            },
            conversation: window.interviewManager.conversationHistory,
            tokenStats: window.tokenMonitor.stats,
            efficiencyReport: window.tokenMonitor.getEfficiencyReport()
        };
    }

    exportAsJSON(data) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json'
        });
        this.downloadFile(blob, 'personahire-interview.json');
    }

    exportAsText(data) {
        let text = `PersonaHire Ultimate - é¢è¯•è®°å½•\n`;
        text += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`;
        text += `é¢è¯•æ—¶é•¿: ${window.interviewManager.getInterviewDuration()}\n`;
        text += `é¢è¯•å®˜ç±»å‹: ${data.metadata.interviewData.personality || 'æœªçŸ¥'}\n`;
        text += `éš¾åº¦ç­‰çº§: ${data.metadata.interviewData.difficulty || 'æœªçŸ¥'}\n`;
        text += `\n${'='.repeat(50)}\n\n`;

        data.conversation.forEach((msg, index) => {
            if (msg.role !== 'system') {
                const sender = msg.role === 'assistant' ? 'AIé¢è¯•å®˜' : 'å€™é€‰äºº';
                text += `${sender}: ${msg.content}\n\n`;
            }
        });

        text += `${'='.repeat(50)}\n`;
        text += `Tokenç»Ÿè®¡:\n`;
        text += `- æ€»Token: ${data.tokenStats.totalTokens}\n`;
        text += `- è¾“å…¥Token: ${data.tokenStats.inputTokens}\n`;
        text += `- è¾“å‡ºToken: ${data.tokenStats.outputTokens}\n`;
        text += `- é¢„è®¡è´¹ç”¨: $${data.tokenStats.totalCost.toFixed(4)}\n`;

        const blob = new Blob([text], { type: 'text/plain; charset=utf-8' });
        this.downloadFile(blob, 'personahire-interview.txt');
    }

    exportAsHTML(data) {
        const html = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>PersonaHire é¢è¯•è®°å½•</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .header { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .message { margin: 15px 0; padding: 15px; border-radius: 8px; }
        .interviewer { background: #e3f2fd; border-left: 4px solid #2196f3; }
        .user { background: #f1f8e9; border-right: 4px solid #4caf50; margin-left: 40px; }
        .stats { background: #fff3e0; padding: 15px; border-radius: 8px; margin-top: 30px; }
        .timestamp { font-size: 0.8em; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ­ PersonaHire Ultimate - é¢è¯•è®°å½•</h1>
        <p><strong>å¯¼å‡ºæ—¶é—´:</strong> ${new Date().toLocaleString()}</p>
        <p><strong>é¢è¯•æ—¶é•¿:</strong> ${window.interviewManager.getInterviewDuration()}</p>
        <p><strong>é¢è¯•å®˜ç±»å‹:</strong> ${data.metadata.interviewData.personality || 'æœªçŸ¥'}</p>
        <p><strong>éš¾åº¦ç­‰çº§:</strong> ${data.metadata.interviewData.difficulty || 'æœªçŸ¥'}</p>
    </div>
    
    <div class="conversation">
        ${data.conversation.filter(msg => msg.role !== 'system').map(msg => `
            <div class="message ${msg.role === 'assistant' ? 'interviewer' : 'user'}">
                <strong>${msg.role === 'assistant' ? 'ğŸ­ AIé¢è¯•å®˜ Sarah' : 'ğŸ‘¤ å€™é€‰äºº'}:</strong>
                <div>${msg.content.replace(/\n/g, '<br>')}</div>
            </div>
        `).join('')}
    </div>
    
    <div class="stats">
        <h3>ğŸ“Š ç»Ÿè®¡ä¿¡æ¯</h3>
        <p><strong>æ€»Tokenä½¿ç”¨:</strong> ${data.tokenStats.totalTokens}</p>
        <p><strong>è¾“å…¥Token:</strong> ${data.tokenStats.inputTokens}</p>
        <p><strong>è¾“å‡ºToken:</strong> ${data.tokenStats.outputTokens}</p>
        <p><strong>é¢„è®¡è´¹ç”¨:</strong> $${data.tokenStats.totalCost.toFixed(4)}</p>
        <p><strong>å¯¹è¯è½®æ•°:</strong> ${data.tokenStats.conversationRounds}</p>
    </div>
</body>
</html>`;

        const blob = new Blob([html], { type: 'text/html; charset=utf-8' });
        this.downloadFile(blob, 'personahire-interview.html');
    }

    downloadFile(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        window.uiManager.showSuccess(`âœ… æ–‡ä»¶å·²å¯¼å‡º: ${filename}`);
    }
}

// åˆå§‹åŒ–ç®¡ç†å™¨
window.uiManager = new UIManager();
window.audioManager = new AudioManager();
window.apiManager = new APIManager();
window.interviewManager = new InterviewManager();
window.exportManager = new ExportManager();

// ç»‘å®šå…¨å±€å‡½æ•°
window.startInterview = () => window.interviewManager.startInterview();
window.sendMessage = () => window.interviewManager.sendMessage();
window.generateReport = () => window.interviewManager.generateReport();
window.endInterview = () => window.interviewManager.endInterview();
window.clearChat = () => window.interviewManager.clearChat();
window.playWelcomeMessage = () => window.audioManager.playAudio('æ¬¢è¿æ¥åˆ°PersonaHire Ultimateï¼æˆ‘æ˜¯æ‚¨çš„ä¸“å±AIé¢è¯•å®˜Sarahï¼Œæ­è½½äº†æœ€å¼ºå¤§çš„GPT-4.1æ¨ç†å¼•æ“ã€‚è®©æˆ‘ä»¬å¼€å§‹ä¸€åœºç²¾å½©çš„é¢è¯•å§ï¼');

// å¯¼å‡ºåŠŸèƒ½
window.exportConversation = (format) => window.exportManager.exportConversation(format);

// åˆ‡æ¢é¢æ¿åŠŸèƒ½
window.toggleAdvancedControls = () => {
    const panel = document.getElementById('advancedControls');
    if (panel) {
        const isVisible = panel.style.display !== 'none';
        panel.style.display = isVisible ? 'none' : 'block';
    }
};

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', () => {
    console.log('ğŸš€ PersonaHire Ultimate å·²åŠ è½½å®Œæˆ');
    
    // åˆå§‹åŒ–UIçŠ¶æ€
    window.uiManager.updateButtonStates({
        canStart: !window.configManager.isDeveloperMode || !!window.configManager.apiKeys.openai,
        canEnd: false,
        canReport: false,
        canSend: false,
        canInput: false
    });

    // ç»‘å®šå›è½¦å‘é€
    const userInput = document.getElementById('userInput');
    if (userInput) {
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!userInput.disabled && !document.getElementById('sendBtn').disabled) {
                    window.sendMessage();
                }
            }
        });
    }

    // æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
    setTimeout(() => {
        if (!window.configManager.isDeveloperMode) {
            window.uiManager.showSuccess('âœ¨ æ¬¢è¿ä½¿ç”¨PersonaHire Ultimateï¼ç‚¹å‡»"å¼€å§‹é¢è¯•"ç«‹å³ä½“éªŒAIé¢è¯•å®˜ã€‚');
        } else {
            window.uiManager.showMessage('ğŸ”§ å¼€å‘è€…æ¨¡å¼å·²å¯ç”¨ï¼Œè¯·é…ç½®APIå¯†é’¥åå¼€å§‹ä½¿ç”¨ã€‚', 'info');
        }
    }, 1000);
});